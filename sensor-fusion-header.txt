#ifndef RTFCS_SENSOR_FUSION_HPP
#define RTFCS_SENSOR_FUSION_HPP

#include <memory>
#include <mutex>
#include <deque>
#include <Eigen/Dense>
#include "rtfcs/types.hpp"
#include "rtfcs/filters/kalman_filter.hpp"

namespace rtfcs {

/**
 * @brief Vehicle state estimated by sensor fusion
 */
struct FusedState {
    Position3D position;          ///< Position in NED frame
    Velocity3D velocity;          ///< Velocity in NED frame
    Attitude attitude;            ///< Vehicle attitude (roll, pitch, yaw)
    AngularRates rates;           ///< Angular rates
    
    // Additional states
    Eigen::Vector3d accel_bias;   ///< Accelerometer bias
    Eigen::Vector3d gyro_bias;    ///< Gyroscope bias
    double baro_bias;             ///< Barometer bias
    
    // Uncertainty
    Eigen::Matrix<double, 15, 15> covariance;  ///< State covariance matrix
    
    // Quality metrics
    uint8_t gps_satellites{0};
    double hdop{99.9};
    double position_accuracy_m{100.0};
    double velocity_accuracy_ms{10.0};
    bool gps_valid{false};
    bool optical_flow_valid{false};
    
    // System state
    double battery_voltage{0.0};
    uint64_t timestamp_us{0};
};

/**
 * @brief Sensor fusion using Extended Kalman Filter
 * 
 * Fuses data from multiple sensors to provide accurate state estimation:
 * - IMU (1000Hz): Acceleration and angular rates
 * - GPS (25Hz): Position and velocity
 * - Barometer (100Hz): Altitude
 * - Magnetometer (100Hz): Heading
 * - Optical flow (optional): Velocity
 * 
 * Achieves <0.5m position accuracy with GPS and <2m accuracy
 * with GPS denied using optical flow.
 */
class SensorFusion {
public:
    SensorFusion();
    ~SensorFusion();

    /**
     * @brief Initialize sensor fusion
     * @return true if initialization successful
     */
    bool initialize();

    /**
     * @brief Add IMU measurement
     * @param data IMU sensor data
     */
    void addIMUData(const IMUData& data);

    /**
     * @brief Add GPS measurement
     * @param data GPS position data
     */
    void addGPSData(const GPSPosition& data);

    /**
     * @brief Add barometer measurement
     * @param data Barometer data
     */
    void addBarometerData(const BarometerData& data);

    /**
     * @brief Add magnetometer measurement
     * @param data Magnetometer reading (Gauss)
     */
    void addMagnetometerData(const std::array<double, 3>& data);

    /**
     * @brief Add optical flow measurement
     * @param flow_x X-axis flow (rad/s)
     * @param flow_y Y-axis flow (rad/s)
     * @param range Range to ground (m)
     * @param quality Flow quality (0-255)
     */
    void addOpticalFlowData(double flow_x, double flow_y, 
                           double range, uint8_t quality);

    /**
     * @brief Update fusion algorithm
     * 
     * Should be called at the main control rate (1000Hz)
     */
    void update();

    /**
     * @brief Get current fused state
     * @return Current state estimate
     */
    FusedState getState() const;

    /**
     * @brief Check if fusion is healthy
     * @return true if all sensors are providing valid data
     */
    bool isHealthy() const;

    /**
     * @brief Check if sensors are calibrated
     * @return true if calibration is complete
     */
    bool isCalibrated() const { return calibrated_; }

    /**
     * @brief Reset fusion to initial state
     */
    void reset();

    /**
     * @brief Set home position
     * @param home GPS home position
     */
    void setHomePosition(const GPSPosition& home);

    /**
     * @brief Get fusion statistics
     */
    struct Statistics {
        uint32_t imu_updates{0};
        uint32_t gps_updates{0};
        uint32_t baro_updates{0};
        uint32_t mag_updates{0};
        uint32_t flow_updates{0};
        
        double avg_imu_dt_ms{0};
        double avg_fusion_time_us{0};
        
        uint32_t gps_rejections{0};
        uint32_t baro_rejections{0};
        uint32_t mag_rejections{0};
    };
    
    Statistics getStatistics() const { return stats_; }

private:
    /**
     * @brief EKF prediction step using IMU data
     */
    void predict(const IMUData& imu);

    /**
     * @brief EKF update step for GPS measurements
     */
    void updateGPS(const GPSPosition& gps);

    /**
     * @brief EKF update step for barometer
     */
    void updateBarometer(const BarometerData& baro);

    /**
     * @brief EKF update step for magnetometer
     */
    void updateMagnetometer(const std::array<double, 3>& mag);

    /**
     * @brief EKF update step for optical flow
     */
    void updateOpticalFlow(double flow_x, double flow_y, 
                          double range, uint8_t quality);

    /**
     * @brief Check measurement validity
     */
    bool isValidGPS(const GPSPosition& gps) const;
    bool isValidBarometer(const BarometerData& baro) const;
    bool isValidMagnetometer(const std::array<double, 3>& mag) const;

    /**
     * @brief Convert GPS to local NED coordinates
     */
    Position3D gpsToNED(const GPSPosition& gps) const;

    /**
     * @brief Update quaternion from angular rates
     */
    void updateQuaternion(const Eigen::Vector3d& gyro, double dt);

    /**
     * @brief Initialize bias estimates
     */
    void initializeBiases();

    // Extended Kalman Filter
    std::unique_ptr<ExtendedKalmanFilter> ekf_;
    
    // State vector: [pos(3), vel(3), quat(4), accel_bias(3), gyro_bias(3)]
    static constexpr int STATE_DIM = 16;
    Eigen::Matrix<double, STATE_DIM, 1> state_;
    Eigen::Matrix<double, STATE_DIM, STATE_DIM> covariance_;

    // Sensor data buffers
    mutable std::mutex data_mutex_;
    std::deque<IMUData> imu_buffer_;
    std::deque<GPSPosition> gps_buffer_;
    std::deque<BarometerData> baro_buffer_;
    
    // Calibration
    bool calibrated_{false};
    bool calibrating_{false};
    uint32_t calibration_samples_{0};
    Eigen::Vector3d accel_offset_{0, 0, 0};
    Eigen::Vector3d gyro_offset_{0, 0, 0};
    
    // Reference positions
    GPSPosition home_position_{};
    bool home_set_{false};
    
    // Timing
    uint64_t last_imu_time_us_{0};
    uint64_t last_gps_time_us_{0};
    uint64_t last_prediction_us_{0};
    
    // Statistics
    Statistics stats_{};
    
    // Configuration
    struct Config {
        // Process noise
        double accel_noise_mss{0.5};
        double gyro_noise_rads{0.01};
        double accel_bias_noise{0.001};
        double gyro_bias_noise{0.0001};
        
        // Measurement noise
        double gps_pos_noise_m{2.0};
        double gps_vel_noise_ms{0.2};
        double baro_noise_m{0.5};
        double mag_noise_gauss{0.1};
        double flow_noise_rads{0.1};
        
        // Outlier rejection thresholds
        double gps_reject_thresh{5.0};  // Standard deviations
        double baro_reject_thresh{3.0};
        double mag_reject_thresh{3.0};
    } config_;
    
    // Magnetic field reference (local magnetic field)
    Eigen::Vector3d mag_reference_{0.2, 0.0, 0.4};  // Default values
};

} // namespace rtfcs

#endif // RTFCS_SENSOR_FUSION_HPP