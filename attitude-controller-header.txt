#ifndef RTFCS_ATTITUDE_CONTROLLER_HPP
#define RTFCS_ATTITUDE_CONTROLLER_HPP

#include <array>
#include <memory>
#include "rtfcs/types.hpp"
#include "rtfcs/control/pid_controller.hpp"

namespace rtfcs {

/**
 * @brief Control output from attitude controller
 */
struct ControlOutput {
    double roll;     ///< Roll control output [-1, 1]
    double pitch;    ///< Pitch control output [-1, 1]
    double yaw;      ///< Yaw control output [-1, 1]
    double thrust;   ///< Thrust output [0, 1]
};

/**
 * @brief Attitude controller implementing cascaded PID control
 * 
 * This controller uses a dual-loop architecture:
 * - Outer loop: Angle control (for ANGLE mode)
 * - Inner loop: Rate control (always active)
 * 
 * The controller achieves <50ms settling time for step inputs
 * and maintains ±1° accuracy in hover conditions.
 */
class AttitudeController {
public:
    /**
     * @brief Control modes
     */
    enum class Mode {
        RATE,     ///< Direct rate control (manual mode)
        ANGLE     ///< Angle control (stabilized modes)
    };

    AttitudeController();
    ~AttitudeController();

    /**
     * @brief Initialize controller with default gains
     */
    void initialize();

    /**
     * @brief Update control loops
     * @param state Current vehicle state
     * @param setpoint Desired setpoint
     * @return Control outputs for motors
     */
    ControlOutput update(const SensorState& state, const ControlSetpoint& setpoint);

    /**
     * @brief Set control mode
     * @param mode Desired control mode
     */
    void setMode(Mode mode) { mode_ = mode; }

    /**
     * @brief Set angle limits
     * @param max_roll_deg Maximum roll angle in degrees
     * @param max_pitch_deg Maximum pitch angle in degrees
     * @param max_yaw_rate_dps Maximum yaw rate in degrees/second
     */
    void setLimits(double max_roll_deg, double max_pitch_deg, double max_yaw_rate_dps);

    /**
     * @brief Set PID gains for rate controllers
     * @param axis 0=roll, 1=pitch, 2=yaw
     * @param kp Proportional gain
     * @param ki Integral gain
     * @param kd Derivative gain
     */
    void setRateGains(int axis, double kp, double ki, double kd);

    /**
     * @brief Set PID gains for angle controllers
     * @param axis 0=roll, 1=pitch
     * @param kp Proportional gain
     * @param ki Integral gain (usually 0)
     * @param kd Derivative gain (usually 0)
     */
    void setAngleGains(int axis, double kp, double ki, double kd);

    /**
     * @brief Reset all integrators
     */
    void reset();

    /**
     * @brief Get current performance metrics
     */
    struct PerformanceMetrics {
        double rate_error_rms[3];      ///< RMS rate error for each axis
        double angle_error_rms[2];     ///< RMS angle error for roll/pitch
        double control_effort[3];      ///< Average control output magnitude
        uint32_t update_count;         ///< Total updates performed
    };
    
    PerformanceMetrics getPerformanceMetrics() const { return metrics_; }

    /**
     * @brief Enable/disable adaptive control
     * @param enable True to enable adaptive gain adjustment
     */
    void enableAdaptiveControl(bool enable) { adaptive_enabled_ = enable; }

private:
    /**
     * @brief Compute rate control outputs
     */
    void updateRateControl(const AngularRates& current_rates, 
                          const AngularRates& desired_rates,
                          ControlOutput& output);

    /**
     * @brief Compute angle control outputs (generates rate setpoints)
     */
    AngularRates updateAngleControl(const Attitude& current_attitude,
                                    const Attitude& desired_attitude);

    /**
     * @brief Apply adaptive control adjustments
     */
    void updateAdaptiveGains();

    /**
     * @brief Limit control outputs to configured ranges
     */
    void limitOutputs(ControlOutput& output);

    /**
     * @brief Update performance metrics
     */
    void updateMetrics(const AngularRates& rate_error, 
                      const Attitude& angle_error);

    // Control mode
    Mode mode_{Mode::ANGLE};

    // PID controllers
    std::unique_ptr<PIDController> rate_controllers_[3];   // Roll, Pitch, Yaw
    std::unique_ptr<PIDController> angle_controllers_[2];  // Roll, Pitch

    // Limits
    double max_roll_deg_{45.0};
    double max_pitch_deg_{45.0};
    double max_yaw_rate_dps_{180.0};
    double max_roll_rate_dps_{360.0};
    double max_pitch_rate_dps_{360.0};

    // Adaptive control
    bool adaptive_enabled_{false};
    double adaptation_rate_{0.001};
    std::array<double, 3> gain_scaling_{1.0, 1.0, 1.0};

    // Performance metrics
    PerformanceMetrics metrics_{};

    // Filters for derivative terms
    std::array<double, 3> rate_filters_{};
    double filter_alpha_{0.1};  // Low-pass filter coefficient

    // Previous values for derivative calculation
    AngularRates prev_rates_{};
    std::chrono::high_resolution_clock::time_point last_update_time_;
};

} // namespace rtfcs

#endif // RTFCS_ATTITUDE_CONTROLLER_HPP